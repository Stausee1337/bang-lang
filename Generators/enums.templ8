{% pymodule enum_parser %}
from dataclasses import dataclass

from Templ8.lexing import TokenStream, expect, test

@dataclass
class Enum:
    name: str
    variants: list

    def __iter__(self):
        yield from self.variants

    def __len__(self):
        return len(self.variants)

    def __getitem__(self, idx):
        return self.variants[idx]

def parse_int(stream: TokenStream):
    return int(expect(stream, 'num:').value)

parsers = {
    'int': parse_int
}

def call_parser(parser, stream):
    if callable(parser):
        return parser(stream)
    elif isinstance(parser, str):
        return parsers[parser](stream)

def parse(Variant: type, arg_parsers: tuple):
    assert isinstance(arg_parsers, tuple)

    def _parse(stream: TokenStream) -> list[Enum]:
        enums: list[Enum] = []
        while not stream.is_eof():
            if test(stream.lookahead(1), 'eof:'):
                break
            expect(stream, 'ident:enum')
            enum_name = expect(stream, 'ident:').value
            expect(stream, 'punct:{') #}

            variants: list[Variant] = []
            while not stream.is_eof():
                if test(stream.lookahead(1), 'punct:}'):
                    break

                variant_name = expect(stream, 'ident:').value;
                arguments = []
                if len(arg_parsers) > 0:
                    expect(stream, 'punct:(') #)

                    for i, parser in enumerate(arg_parsers):
                        arguments.append(call_parser(parser, stream))
                        if i != len(arg_parsers)-1:
                            expect(stream, 'punct:,')

                    expect(stream, 'punct:)')
                expect(stream, 'punct:;')

                variants.append(Variant(variant_name, *arguments))

            enums.append(Enum(enum_name, variants))

            expect(stream, 'punct:}')
        return enums
    return _parse
{% endmodule %}
{% pyimport phf_generator as _utils %}

{% macro enum_to_string in enum %}

static inline
const char *{{ enum.name|snake_case|lower }}_to_string({{ enum.name }} in) {
    {% def MAPPING_NAME = f'{ enum.name|snake_case|lower }_str_map' %}
    static const char *{{ MAPPING_NAME }}[{{ enum|ilen }}] = {
        {% for variant : enum %}
        {{ variant.name|_utils.format_to_string_literal }},
        {% endfor %}
    };
    assert(in < {{ enum|ilen }});

    return {{ MAPPING_NAME }}[in];
}
{% endmacro %}

{% macro define_enum in enum %}
{% def variant_prefix = enum.name|prefix|title %}
{% eval (top_lines, '#include <assert.h>')|qappend %}

#define {{ enum|ilen }} {{ enum|len }}

typedef enum {
    {{ variant_prefix }}_Invalid = -1,
{% for variant : enum %}
    {{ variant_prefix }}_{{ variant.name }},
{% endfor %}
    {{ variant_prefix }}_NumberOfElements
} {{ enum.name }};

static_assert({{ variant_prefix }}_NumberOfElements == {{ enum|ilen }}, "Number of enum {{ enum.name }} elements changed. This file was generated by {{ __FILENAME__ }}, edit this instead");
{% endmacro %}

{% macro header_include_guard %}
{% eval (top_lines, f'// this file was generated from {__FILENAME__}')|qappend %}
{% def file_name = '.templ8'|__FILENAME__.rstrip %}
{% def file_name = (('.', '_')|file_name.replace)|upper %}
{% eval (top_lines,    f'#ifndef  {file_name}_')|qappend %}
{% eval (top_lines,    f'#define  {file_name}_')|qappend %}
{% eval (top_lines,     '')|qappend %}
{% eval (bottom_lines, f'#endif //{file_name}_')|qappend %}
{% endmacro %}

{% export $define_enum $header_include_guard $enum_to_string enum_parser %}
