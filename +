#ifndef UTF8_H_
#define UTF8_H_

#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define UTF8_SLICE_BUMP(string)                             \
    do {                                                    \
    if ((string)->length > 0) {                             \
        assert(utf8_char_size((string)->data) > 0);         \
        (string)->data += utf8_char_size((string)->data);   \
        (string)->length--;                                 \
    }                                                       \
    } while (0)

typedef struct {
    const char *data;
    size_t length;
} Utf8Slice;

static inline size_t utf8_char_size(const char utf8_char) {
#define CHR_AND(b)  ((utf8_char) & b) 
    if (CHR_AND(0x80) == 0) {
        return 1;
    }
    if (CHR_AND(0xe0) == 0xc0) {
        return 2;
    }
    if (CHR_AND(0xf0) == 0xe0) {
        return 3;
    }
    if (CHR_AND(0xf8) == 0xf0) {
        return 4;
    }
    return 0;
#undef CHR_AND
}

static inline
bool utf8_slice_get_ascii_char(Utf8Slice *slice, char *out) {
    if ((*slice->data & 0x80) == 0) {
        *out = *slice->data;
        return true;
    }
    return false;
}


static inline
bool utf8_slice_get_char(Utf8Slice *slice, uint32_t *unicode_char) {
    if (slice->length == 0) {
        return false;
    }
    switch (utf8_char_size(*slice->data)) {
        case 0:
        case 1:
            {
                *unicode_char = (uint32_t)*slice->data;
                break;
            }
        case 2:
            {
                char c1 = slice->data[0];
                char c2 = slice->data[1];

                *unicode_char = ((c1 << 6) );
                break;
            }
        default:    
            assert(0 && "unreachable");
            break;
    }
    return true;
}

size_t utf8_str_getlen(const char *str);
Utf8Slice utf8_slice_new(const char *str);
Utf8Slice utf8_slice_new_copy(const char *str);

#endif // UTF8_H
