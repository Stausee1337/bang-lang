struct Matrix($T, $XSize, $YSize)
where:
    $XSize/const usize, $YSize/const usize
{
    array $T[$YSize][$XSize];
}

struct TArray($T) {
    elements *$T;
    count usize;
    capacity usize;
}

fn push(this $G/TArray($T), item $T) {
    ...
}

struct String {
    elements *u8;
    count usize;
    capacity usize;
}

fn entry() {
    my_string := String { 0 };
    my_string.push(b'8');
}

struct Formatter {
    ...
}

// +++ Maybe this is the only possibility to do weird type based interfaces
struct Formattable($FormatFunc)
where:
    $FormatFunc/const fn($T/Formattable, Formatter) String;


// OK, that looks pretty right! Only question to solve now:
// How does anything (any other struct) "look like a Formattable"
// to allow for the ducktyping


fn push_arg(this Formatter, arg: $T/Formattable($FromatFunc))
{
    format_str := $FormatFunc(arg, this);
    ...
}

// +++ only possibility to do weird type based interfaces END

struct TArray {
    ...
}

TArray:format(this TArray, formatter Formatter) String {

}

// how does TArray look like a Formattable
