// this file was generated from lexerc.h.templ8
#ifndef  LEXERC_H_
#define  LEXERC_H_

#include <assert.h>
#include <stdint.h>
#include <string.h>

uint64_t thirdparty_siphash24(const void *src, unsigned long src_sz, const char key[16]);

#define NUM_ENTRIES_KEYWORD 14

typedef enum {
    K_Invalid = -1,
    K_Nil,
    K_True,
    K_False,
    K_If,
    K_Else,
    K_For,
    K_Loop,
    K_While,
    K_Break,
    K_Continue,
    K_Fn,
    K_Enum,
    K_Struct,
    K_Variant,
    K_NumberOfElements
} Keyword;

static_assert(K_NumberOfElements == NUM_ENTRIES_KEYWORD, "Number of enum Keyword elements changed. This file was generated by lexerc.h.templ8, edit this instead");

static inline
const char *keyword_to_string(Keyword in) {
    static const char *keyword_str_map[NUM_ENTRIES_KEYWORD] = {
        "Nil",
        "True",
        "False",
        "If",
        "Else",
        "For",
        "Loop",
        "While",
        "Break",
        "Continue",
        "Fn",
        "Enum",
        "Struct",
        "Variant",
    };
    assert(in < NUM_ENTRIES_KEYWORD);

    return keyword_str_map[in];
}

static inline
Keyword keyword_resolve(const char * in) {
    static const struct _k_struct_tuple { const char * _0; Keyword _1; } _k_entries[NUM_ENTRIES_KEYWORD] = {
        { "fn", K_Fn },
        { "enum", K_Enum },
        { "for", K_For },
        { "if", K_If },
        { "else", K_Else },
        { "true", K_True },
        { "continue", K_Continue },
        { "nil", K_Nil },
        { "struct", K_Struct },
        { "false", K_False },
        { "variant", K_Variant },
        { "while", K_While },
        { "break", K_Break },
        { "loop", K_Loop },
    };
    
#define NUM_K_DISPS 3
    static const uint32_t _k_disps[NUM_K_DISPS][2] = 
        { { 0, 11 }, { 0, 0 }, { 1, 5 },  };
    static const char* _k_hashkey = "\x00\x00\x00\x00\x00\x00\x00\x00P\xdb\xb1\xeb\x9a\xa1K\x95";

    uint64_t hash = thirdparty_siphash24(in, strlen(in), _k_hashkey);
    const uint32_t lower = hash & 0xffffffff;
    const uint32_t upper = (hash >> 32) & 0xffffffff;

    const uint32_t g = (lower >> 16);
    const uint32_t f1 = lower;
    const uint32_t f2 = upper;

    const uint32_t *d = _k_disps[(g % NUM_K_DISPS)];
    const uint32_t idx = (d[1] + f1 * d[0] + f2) % NUM_ENTRIES_KEYWORD;
    const struct _k_struct_tuple entry = _k_entries[idx];

    if (entry._0 != in) {
        return K_Invalid;
    }
    return entry._1;

#undef NUM_K_DISPS
}

#define NUM_ENTRIES_DIRECTIVE 4

typedef enum {
    D_Invalid = -1,
    D_If,
    D_Else,
    D_Include,
    D_Open,
    D_NumberOfElements
} Directive;

static_assert(D_NumberOfElements == NUM_ENTRIES_DIRECTIVE, "Number of enum Directive elements changed. This file was generated by lexerc.h.templ8, edit this instead");

static inline
const char *directive_to_string(Directive in) {
    static const char *directive_str_map[NUM_ENTRIES_DIRECTIVE] = {
        "If",
        "Else",
        "Include",
        "Open",
    };
    assert(in < NUM_ENTRIES_DIRECTIVE);

    return directive_str_map[in];
}

static inline
Directive directive_resolve(const char * in) {
    static const struct _d_struct_tuple { const char * _0; Directive _1; } _d_entries[NUM_ENTRIES_DIRECTIVE] = {
        { "else", D_Else },
        { "include", D_Include },
        { "open", D_Open },
        { "if", D_If },
    };
    
#define NUM_D_DISPS 1
    static const uint32_t _d_disps[NUM_D_DISPS][2] = 
        { { 0, 0 },  };
    static const char* _d_hashkey = "\x00\x00\x00\x00\x00\x00\x00\x00t\xfe\x86\xe4Q\xec\x10\xc1";

    uint64_t hash = thirdparty_siphash24(in, strlen(in), _d_hashkey);
    const uint32_t lower = hash & 0xffffffff;
    const uint32_t upper = (hash >> 32) & 0xffffffff;

    const uint32_t g = (lower >> 16);
    const uint32_t f1 = lower;
    const uint32_t f2 = upper;

    const uint32_t *d = _d_disps[(g % NUM_D_DISPS)];
    const uint32_t idx = (d[1] + f1 * d[0] + f2) % NUM_ENTRIES_DIRECTIVE;
    const struct _d_struct_tuple entry = _d_entries[idx];

    if (entry._0 != in) {
        return D_Invalid;
    }
    return entry._1;

#undef NUM_D_DISPS
}

#define NUM_ENTRIES_NUMBER_CLASS 14

typedef enum {
    Nc_Invalid = -1,
    Nc_i8,
    Nc_u8,
    Nc_i16,
    Nc_u16,
    Nc_i32,
    Nc_u32,
    Nc_i64,
    Nc_u64,
    Nc_isize,
    Nc_usize,
    Nc_f32,
    Nc_f64,
    Nc_Number,
    Nc_FloatingPointNumber,
    Nc_NumberOfElements
} NumberClass;

static_assert(Nc_NumberOfElements == NUM_ENTRIES_NUMBER_CLASS, "Number of enum NumberClass elements changed. This file was generated by lexerc.h.templ8, edit this instead");

static inline
const char *number_class_to_string(NumberClass in) {
    static const char *number_class_str_map[NUM_ENTRIES_NUMBER_CLASS] = {
        "i8",
        "u8",
        "i16",
        "u16",
        "i32",
        "u32",
        "i64",
        "u64",
        "isize",
        "usize",
        "f32",
        "f64",
        "Number",
        "FloatingPointNumber",
    };
    assert(in < NUM_ENTRIES_NUMBER_CLASS);

    return number_class_str_map[in];
}

static inline
NumberClass number_class_resolve(const char * in) {
    static const struct _nc_struct_tuple { const char * _0; NumberClass _1; } _nc_entries[NUM_ENTRIES_NUMBER_CLASS] = {
        { "u8", Nc_u8 },
        { "i64", Nc_i64 },
        { "i16", Nc_i16 },
        { "number", Nc_Number },
        { "f32", Nc_f32 },
        { "i32", Nc_i32 },
        { "u32", Nc_u32 },
        { "u64", Nc_u64 },
        { "isize", Nc_isize },
        { "floatingpointnumber", Nc_FloatingPointNumber },
        { "f64", Nc_f64 },
        { "u16", Nc_u16 },
        { "i8", Nc_i8 },
        { "usize", Nc_usize },
    };
    
#define NUM_NC_DISPS 3
    static const uint32_t _nc_disps[NUM_NC_DISPS][2] = 
        { { 10, 0 }, { 6, 12 }, { 0, 12 },  };
    static const char* _nc_hashkey = "\x00\x00\x00\x00\x00\x00\x00\x00t\xfe\x86\xe4Q\xec\x10\xc1";

    uint64_t hash = thirdparty_siphash24(in, strlen(in), _nc_hashkey);
    const uint32_t lower = hash & 0xffffffff;
    const uint32_t upper = (hash >> 32) & 0xffffffff;

    const uint32_t g = (lower >> 16);
    const uint32_t f1 = lower;
    const uint32_t f2 = upper;

    const uint32_t *d = _nc_disps[(g % NUM_NC_DISPS)];
    const uint32_t idx = (d[1] + f1 * d[0] + f2) % NUM_ENTRIES_NUMBER_CLASS;
    const struct _nc_struct_tuple entry = _nc_entries[idx];

    if (entry._0 != in) {
        return Nc_Invalid;
    }
    return entry._1;

#undef NUM_NC_DISPS
}

#endif //LEXERC_H_